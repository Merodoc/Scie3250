}
y = y + (nij*log(testvec[i]) - nij*log(testvec[i] + testvec[j]))
}
print(winner)
parvec[i] <- y
}
}
}
print(parvec)
}
NRL <- read.csv(file = "NRL.csv", row.names = 1)
BradTer(NRL)
# Bradley Terry Implementation with Additional Flexibility
# Rowan Elson-Green - University of Queensland School of Mathematics and Physics
library("BradleyTerry2")
FuncSum1 <- function(f, vector1) {
ans <- 0
for (val in vector1) {
ans = ans + f(val)
}
print(ans)
}
BradTer <- function(dataset) {
# outcome <- arbitrary parameter matrix
# player 1 and 2 corresponding to the winner/loser of outcome columns
wintable <- as.data.frame(table(dataset))
# Converts to table of counts
K <- length(unique(dataset[,1]))
testvec <- rep(1, nrow(dataset))
parvec <- c(1:16)
for (i in 1:K) {
team1 <- levels(wintable[,1])[i]
for (j in 1:K) {
team2 <- levels(wintable[,2])[j]
count <- 0
## algorithm for single comparison
for (winner in wintable[,1]) {
count <- count + 1
x <- count
wij <- 0
y <- 0
if(winner == team1) {
if(wintable[,2][count] == team2) {
nij <- wij + wintable[x,3]
}
y = y + (nij*log(testvec[i]) - nij*log(testvec[i] + testvec[j]))
}
print(winner)
parvec[i] <- y
}
}
}
print(parvec)
}
NRL <- read.csv(file = "NRL.csv", row.names = 1)
BradTer(NRL)
# Bradley Terry Implementation with Additional Flexibility
# Rowan Elson-Green - University of Queensland School of Mathematics and Physics
library("BradleyTerry2")
FuncSum1 <- function(f, vector1) {
ans <- 0
for (val in vector1) {
ans = ans + f(val)
}
print(ans)
}
BradTer <- function(dataset) {
# outcome <- arbitrary parameter matrix
# player 1 and 2 corresponding to the winner/loser of outcome columns
wintable <- as.data.frame(table(dataset))
# Converts to table of counts
K <- length(unique(dataset[,1]))
testvec <- rep(1, nrow(dataset))
parvec <- c(1:16)
for (i in 1:K) {
team1 <- levels(wintable[,1])[i]
for (j in 1:K) {
team2 <- levels(wintable[,2])[j]
count <- 0
## algorithm for single comparison
for (winner in wintable[,1]) {
count <- count + 1
x <- count
wij <- 0
y <- 0
if(winner == team1) {
if(wintable[,2][count] == team2) {
nij <- wij + wintable[x,3]
}
y = y + (nij*log(testvec[i]) - nij*log(testvec[i] + testvec[j]))
z <- y
}
print(winner)
parvec[i] <- z
}
}
}
print(parvec)
}
NRL <- read.csv(file = "NRL.csv", row.names = 1)
BradTer(NRL)
# Bradley Terry Implementation with Additional Flexibility
# Rowan Elson-Green - University of Queensland School of Mathematics and Physics
library("BradleyTerry2")
FuncSum1 <- function(f, vector1) {
ans <- 0
for (val in vector1) {
ans = ans + f(val)
}
print(ans)
}
BradTer <- function(dataset) {
# outcome <- arbitrary parameter matrix
# player 1 and 2 corresponding to the winner/loser of outcome columns
wintable <- as.data.frame(table(dataset))
# Converts to table of counts
K <- length(unique(dataset[,1]))
testvec <- rep(1, nrow(dataset))
parvec <- c(1:16)
for (i in 1:K) {
team1 <- levels(wintable[,1])[i]
y <- 0
for (j in 1:K) {
team2 <- levels(wintable[,2])[j]
count <- 0
## algorithm for single comparison
for (winner in wintable[,1]) {
count <- count + 1
x <- count
wij <- 0
if(winner == team1) {
if(wintable[,2][count] == team2) {
nij <- wij + wintable[x,3]
}
y = y + (nij*log(testvec[i]) - nij*log(testvec[i] + testvec[j]))
z <- y
}
print(winner)
parvec[i] <- z
}
}
}
print(parvec)
}
NRL <- read.csv(file = "NRL.csv", row.names = 1)
BradTer(NRL)
# Bradley Terry Implementation with Additional Flexibility
# Rowan Elson-Green - University of Queensland School of Mathematics and Physics
library("BradleyTerry2")
FuncSum1 <- function(f, vector1) {
ans <- 0
for (val in vector1) {
ans = ans + f(val)
}
print(ans)
}
BradTer <- function(dataset) {
# outcome <- arbitrary parameter matrix
# player 1 and 2 corresponding to the winner/loser of outcome columns
wintable <- as.data.frame(table(dataset))
# Converts to table of counts
K <- length(unique(dataset[,1]))
testvec <- rep(1, nrow(dataset))
parvec <- c(1:16)
for (i in 1:K) {
team1 <- levels(wintable[,1])[i]
y <- 0
for (j in 1:K) {
team2 <- levels(wintable[,2])[j]
count <- 0
## algorithm for single comparison
for (winner in wintable[,1]) {
count <- count + 1
x <- count
wij <- 0
if(winner == team1) {
if(wintable[,2][count] == team2) {
nij <- wij + wintable[x,3]
}
y = y + (nij*log(testvec[i]) - nij*log(testvec[i] + testvec[j]))
z <- y
}
parvec[i] <- z
}
}
}
print(parvec)
}
NRL <- read.csv(file = "NRL.csv", row.names = 1)
BradTer(NRL)
NRL[,1]
# Predictor set from BradleyTerry2
# Allows user to find win probabilities for a contest
library("BradleyTerry2")
BTmpredict <- function(model1, player1, player2) {
# For the test model (NRL 2017 dataset) player names have a .. in front
# e.g for player1 to be Broncos, must be ..BRO
mod <- model1$coefficients
logodds <- c()
players <- (1:length(model1$coefficients))
for (i in players) {
logodds <- c(logodds, mod[i])
}
ans <- logodds[player1]/(logodds[player1]+logodds[player2])
names(ans) = c()
cat(player1, "Has a", ans, "chance of beating", player2)
}
NRL <- read.csv(file = "NRL.csv", row.names=1)
results <- rep(1, nrow(NRL))
NRLModel <- BTm(results, Winner, Loser, data = NRL, refcat="NEW")
summary(NRLModel)
BTmpredict(NRLModel, "..BRO", "..MEL")
# Bradley Terry Implementation with Additional Flexibility
# Rowan Elson-Green - University of Queensland School of Mathematics and Physics
library("BradleyTerry2")
FuncSum1 <- function(f, vector1) {
ans <- 0
for (val in vector1) {
ans = ans + f(val)
}
print(ans)
}
BradTer <- function(dataset) {
# outcome <- arbitrary parameter matrix
# player 1 and 2 corresponding to the winner/loser of outcome columns
wintable <- as.data.frame(table(dataset))
# Converts to table of counts
K <- length(unique(dataset[,1]))
testvec <- rep(1, nrow(dataset))
parvec <- c(1:16)
for (i in 1:K) {
team1 <- levels(wintable[,1])[i]
y <- 0
for (j in 1:K) {
team2 <- levels(wintable[,2])[j]
count <- 0
## algorithm for single comparison
for (winner in wintable[,1]) {
count <- count + 1
x <- count
wij <- 0
if(winner == team1) {
if(wintable[,2][count] == team2) {
nij <- wij + wintable[x,3]
}
y = y + (nij*log(parvec[i]) - nij*log(parvec[i] + parvec[j]))
z <- y
}
parvec[i] <- z
}
}
}
print(parvec)
}
NRL <- read.csv(file = "NRL.csv", row.names = 1)
BradTer(NRL)
# Bradley Terry Implementation with Additional Flexibility
# Rowan Elson-Green - University of Queensland School of Mathematics and Physics
library("BradleyTerry2")
FuncSum1 <- function(f, vector1) {
ans <- 0
for (val in vector1) {
ans = ans + f(val)
}
print(ans)
}
BradTer <- function(dataset) {
# outcome <- arbitrary parameter matrix
# player 1 and 2 corresponding to the winner/loser of outcome columns
wintable <- as.data.frame(table(dataset))
# Converts to table of counts
K <- length(unique(dataset[,1]))
testvec <- rep(1, nrow(dataset))
parvec <- c(1:16)
for (i in 1:K) {
team1 <- levels(wintable[,1])[i]
y <- 0
for (j in 1:K) {
team2 <- levels(wintable[,2])[j]
count <- 0
## algorithm for single comparison
for (winner in wintable[,1]) {
count <- count + 1
x <- count
wij <- 0
if(winner == team1) {
if(wintable[,2][count] == team2) {
nij <- wij + wintable[x,3]
}
y = y + (nij*log(testvec[i]) - nij*log(testvec[i] + testvec[j]))
z <- y
}
parvec[i] <- z
}
}
}
print(parvec)
}
NRL <- read.csv(file = "NRL.csv", row.names = 1)
BradTer(NRL)
# Bradley Terry Implementation with Additional Flexibility
# Rowan Elson-Green - University of Queensland School of Mathematics and Physics
library("BradleyTerry2")
FuncSum1 <- function(f, vector1) {
ans <- 0
for (val in vector1) {
ans = ans + f(val)
}
print(ans)
}
BradTer <- function(dataset) {
# outcome <- arbitrary parameter matrix
# player 1 and 2 corresponding to the winner/loser of outcome columns
wintable <- as.data.frame(table(dataset))
# Converts to table of counts
K <- length(unique(dataset[,1]))
testvec <- rep(1, nrow(dataset))
parvec <- c(1:16)
for (i in 1:K) {
team1 <- levels(wintable[,1])[i]
print(team1)
y <- 0
for (j in 1:K) {
team2 <- levels(wintable[,2])[j]
count <- 0
## algorithm for single comparison
for (winner in wintable[,1]) {
count <- count + 1
x <- count
wij <- 0
if(winner == team1) {
if(wintable[,2][count] == team2) {
nij <- wij + wintable[x,3]
}
y = y + (nij*log(testvec[i]) - nij*log(testvec[i] + testvec[j]))
z <- y
}
parvec[i] <- z
}
}
}
print(parvec)
}
NRL <- read.csv(file = "NRL.csv", row.names = 1)
BradTer(NRL)
# Predictor set from BradleyTerry2
# Allows user to find win probabilities for a contest
library("BradleyTerry2")
BTmpredict <- function(model1, player1, player2) {
# For the test model (NRL 2017 dataset) player names have a .. in front
# e.g for player1 to be Broncos, must be ..BRO
mod <- model1$coefficients
logodds <- c()
players <- (1:length(model1$coefficients))
for (i in players) {
logodds <- c(logodds, mod[i])
}
ans <- logodds[player1]/(logodds[player1]+logodds[player2])
names(ans) = c()
cat(player1, "Has a", ans, "chance of beating", player2)
}
NRL <- read.csv(file = "NRL.csv", row.names=1)
results <- rep(1, nrow(NRL))
NRLModel <- BTm(results, Winner, Loser, data = NRL, refcat="NEW")
summary(NRLModel)
BTmpredict(NRLModel, "..BRO", "..MEL")
# Bradley Terry Implementation with Additional Flexibility
# Rowan Elson-Green - University of Queensland School of Mathematics and Physics
library("BradleyTerry2")
FuncSum1 <- function(f, vector1) {
ans <- 0
for (val in vector1) {
ans = ans + f(val)
}
print(ans)
}
BradTer <- function(dataset) {
# outcome <- arbitrary parameter matrix
# player 1 and 2 corresponding to the winner/loser of outcome columns
wintable <- as.data.frame(table(dataset))
# Converts to table of counts
K <- length(unique(dataset[,1]))
testvec <- rep(1, nrow(dataset))
parvec <- c(1:16)
teamnames <- c()
for (i in 1:K) {
team1 <- levels(wintable[,1])[i]
teamnames <- c(teamnames, team1)
y <- 0
for (j in 1:K) {
team2 <- levels(wintable[,2])[j]
count <- 0
## algorithm for single comparison
for (winner in wintable[,1]) {
count <- count + 1
x <- count
wij <- 0
if(winner == team1) {
if(wintable[,2][count] == team2) {
nij <- wij + wintable[x,3]
}
y = y + (nij*log(testvec[i]) - nij*log(testvec[i] + testvec[j]))
z <- y
}
parvec[i] <- z
}
}
}
names(parvec) <- teamnames
print(parvec)
}
NRL <- read.csv(file = "NRL.csv", row.names = 1)
BradTer(NRL)
# Bradley Terry Implementation with Additional Flexibility
# Rowan Elson-Green - University of Queensland School of Mathematics and Physics
library("BradleyTerry2")
FuncSum1 <- function(f, vector1) {
ans <- 0
for (val in vector1) {
ans = ans + f(val)
}
print(ans)
}
BradTer <- function(dataset) {
# outcome <- arbitrary parameter matrix
# player 1 and 2 corresponding to the winner/loser of outcome columns
wintable <- as.data.frame(table(dataset))
# Converts to table of counts
K <- length(unique(dataset[,1]))
testvec <- array(1, 16)/16
parvec <- c(1:16)
teamnames <- c()
for (i in 1:K) {
team1 <- levels(wintable[,1])[i]
teamnames <- c(teamnames, team1)
y <- 0
for (j in 1:K) {
team2 <- levels(wintable[,2])[j]
count <- 0
## algorithm for single comparison
for (winner in wintable[,1]) {
count <- count + 1
x <- count
wij <- 0
if(winner == team1) {
if(wintable[,2][count] == team2) {
nij <- wij + wintable[x,3]
}
y = y + (nij*log(testvec[i]) - nij*log(testvec[i] + testvec[j]))
z <- y
}
parvec[i] <- z
}
}
}
names(parvec) <- teamnames
print(parvec)
}
NRL <- read.csv(file = "NRL.csv", row.names = 1)
BradTer(NRL)
# Bradley Terry Implementation with Additional Flexibility
# Rowan Elson-Green - University of Queensland School of Mathematics and Physics
library("BradleyTerry2")
FuncSum1 <- function(f, vector1) {
ans <- 0
for (val in vector1) {
ans = ans + f(val)
}
print(ans)
}
BradTer <- function(dataset) {
# outcome <- arbitrary parameter matrix
# player 1 and 2 corresponding to the winner/loser of outcome columns
wintable <- as.data.frame(table(dataset))
# Converts to table of counts
K <- length(unique(dataset[,1]))
testvec <- array(1, 16)/16
print(testvec)
parvec <- c(1:16)
teamnames <- c()
for (i in 1:K) {
team1 <- levels(wintable[,1])[i]
teamnames <- c(teamnames, team1)
y <- 0
for (j in 1:K) {
team2 <- levels(wintable[,2])[j]
count <- 0
## algorithm for single comparison
for (winner in wintable[,1]) {
count <- count + 1
x <- count
wij <- 0
if(winner == team1) {
if(wintable[,2][count] == team2) {
nij <- wij + wintable[x,3]
}
y = y + (nij*log(testvec[i]) - nij*log(testvec[i] + testvec[j]))
z <- y
}
parvec[i] <- z
}
}
}
names(parvec) <- teamnames
print(parvec)
}
NRL <- read.csv(file = "NRL.csv", row.names = 1)
BradTer(NRL)
table(NRL)
as.data.frame(NRL)
as.data.frame(table(NRL))
countsToBinomial(as.data.frame(table(NRL)))
