<<<<<<< HEAD
}
y = y + (nij*log(testvec[i]) - nij*log(testvec[i] + testvec[j]))
}
print(winner)
parvec[i] <- y
}
}
}
print(parvec)
}
NRL <- read.csv(file = "NRL.csv", row.names = 1)
BradTer(NRL)
# Bradley Terry Implementation with Additional Flexibility
# Rowan Elson-Green - University of Queensland School of Mathematics and Physics
library("BradleyTerry2")
FuncSum1 <- function(f, vector1) {
ans <- 0
for (val in vector1) {
ans = ans + f(val)
}
print(ans)
}
BradTer <- function(dataset) {
# outcome <- arbitrary parameter matrix
# player 1 and 2 corresponding to the winner/loser of outcome columns
wintable <- as.data.frame(table(dataset))
# Converts to table of counts
K <- length(unique(dataset[,1]))
testvec <- rep(1, nrow(dataset))
parvec <- c(1:16)
for (i in 1:K) {
team1 <- levels(wintable[,1])[i]
for (j in 1:K) {
team2 <- levels(wintable[,2])[j]
count <- 0
## algorithm for single comparison
for (winner in wintable[,1]) {
count <- count + 1
x <- count
wij <- 0
y <- 0
if(winner == team1) {
if(wintable[,2][count] == team2) {
nij <- wij + wintable[x,3]
}
y = y + (nij*log(testvec[i]) - nij*log(testvec[i] + testvec[j]))
}
print(winner)
parvec[i] <- y
}
}
}
print(parvec)
}
NRL <- read.csv(file = "NRL.csv", row.names = 1)
BradTer(NRL)
# Bradley Terry Implementation with Additional Flexibility
# Rowan Elson-Green - University of Queensland School of Mathematics and Physics
library("BradleyTerry2")
FuncSum1 <- function(f, vector1) {
ans <- 0
for (val in vector1) {
ans = ans + f(val)
}
print(ans)
}
BradTer <- function(dataset) {
# outcome <- arbitrary parameter matrix
# player 1 and 2 corresponding to the winner/loser of outcome columns
wintable <- as.data.frame(table(dataset))
# Converts to table of counts
K <- length(unique(dataset[,1]))
testvec <- rep(1, nrow(dataset))
parvec <- c(1:16)
for (i in 1:K) {
team1 <- levels(wintable[,1])[i]
for (j in 1:K) {
team2 <- levels(wintable[,2])[j]
count <- 0
## algorithm for single comparison
for (winner in wintable[,1]) {
count <- count + 1
x <- count
wij <- 0
y <- 0
if(winner == team1) {
if(wintable[,2][count] == team2) {
nij <- wij + wintable[x,3]
}
y = y + (nij*log(testvec[i]) - nij*log(testvec[i] + testvec[j]))
z <- y
}
print(winner)
parvec[i] <- z
}
}
}
print(parvec)
}
NRL <- read.csv(file = "NRL.csv", row.names = 1)
BradTer(NRL)
# Bradley Terry Implementation with Additional Flexibility
# Rowan Elson-Green - University of Queensland School of Mathematics and Physics
library("BradleyTerry2")
FuncSum1 <- function(f, vector1) {
ans <- 0
for (val in vector1) {
ans = ans + f(val)
}
print(ans)
}
BradTer <- function(dataset) {
# outcome <- arbitrary parameter matrix
# player 1 and 2 corresponding to the winner/loser of outcome columns
wintable <- as.data.frame(table(dataset))
# Converts to table of counts
K <- length(unique(dataset[,1]))
testvec <- rep(1, nrow(dataset))
parvec <- c(1:16)
for (i in 1:K) {
team1 <- levels(wintable[,1])[i]
y <- 0
for (j in 1:K) {
team2 <- levels(wintable[,2])[j]
count <- 0
## algorithm for single comparison
for (winner in wintable[,1]) {
count <- count + 1
x <- count
wij <- 0
if(winner == team1) {
if(wintable[,2][count] == team2) {
nij <- wij + wintable[x,3]
}
y = y + (nij*log(testvec[i]) - nij*log(testvec[i] + testvec[j]))
z <- y
}
print(winner)
parvec[i] <- z
}
}
}
print(parvec)
}
NRL <- read.csv(file = "NRL.csv", row.names = 1)
BradTer(NRL)
# Bradley Terry Implementation with Additional Flexibility
# Rowan Elson-Green - University of Queensland School of Mathematics and Physics
library("BradleyTerry2")
FuncSum1 <- function(f, vector1) {
ans <- 0
for (val in vector1) {
ans = ans + f(val)
}
print(ans)
}
BradTer <- function(dataset) {
# outcome <- arbitrary parameter matrix
# player 1 and 2 corresponding to the winner/loser of outcome columns
wintable <- as.data.frame(table(dataset))
# Converts to table of counts
K <- length(unique(dataset[,1]))
testvec <- rep(1, nrow(dataset))
parvec <- c(1:16)
for (i in 1:K) {
team1 <- levels(wintable[,1])[i]
y <- 0
for (j in 1:K) {
team2 <- levels(wintable[,2])[j]
count <- 0
## algorithm for single comparison
for (winner in wintable[,1]) {
count <- count + 1
x <- count
wij <- 0
if(winner == team1) {
if(wintable[,2][count] == team2) {
nij <- wij + wintable[x,3]
}
y = y + (nij*log(testvec[i]) - nij*log(testvec[i] + testvec[j]))
z <- y
}
parvec[i] <- z
}
}
}
print(parvec)
}
NRL <- read.csv(file = "NRL.csv", row.names = 1)
BradTer(NRL)
NRL[,1]
# Predictor set from BradleyTerry2
# Allows user to find win probabilities for a contest
library("BradleyTerry2")
BTmpredict <- function(model1, player1, player2) {
# For the test model (NRL 2017 dataset) player names have a .. in front
# e.g for player1 to be Broncos, must be ..BRO
mod <- model1$coefficients
logodds <- c()
players <- (1:length(model1$coefficients))
for (i in players) {
logodds <- c(logodds, mod[i])
}
ans <- logodds[player1]/(logodds[player1]+logodds[player2])
names(ans) = c()
cat(player1, "Has a", ans, "chance of beating", player2)
}
NRL <- read.csv(file = "NRL.csv", row.names=1)
results <- rep(1, nrow(NRL))
NRLModel <- BTm(results, Winner, Loser, data = NRL, refcat="NEW")
summary(NRLModel)
BTmpredict(NRLModel, "..BRO", "..MEL")
# Bradley Terry Implementation with Additional Flexibility
# Rowan Elson-Green - University of Queensland School of Mathematics and Physics
library("BradleyTerry2")
FuncSum1 <- function(f, vector1) {
ans <- 0
for (val in vector1) {
ans = ans + f(val)
}
print(ans)
}
BradTer <- function(dataset) {
# outcome <- arbitrary parameter matrix
# player 1 and 2 corresponding to the winner/loser of outcome columns
wintable <- as.data.frame(table(dataset))
# Converts to table of counts
K <- length(unique(dataset[,1]))
testvec <- rep(1, nrow(dataset))
parvec <- c(1:16)
for (i in 1:K) {
team1 <- levels(wintable[,1])[i]
y <- 0
for (j in 1:K) {
team2 <- levels(wintable[,2])[j]
count <- 0
## algorithm for single comparison
for (winner in wintable[,1]) {
count <- count + 1
x <- count
wij <- 0
if(winner == team1) {
if(wintable[,2][count] == team2) {
nij <- wij + wintable[x,3]
}
y = y + (nij*log(parvec[i]) - nij*log(parvec[i] + parvec[j]))
z <- y
}
parvec[i] <- z
}
}
}
print(parvec)
}
NRL <- read.csv(file = "NRL.csv", row.names = 1)
BradTer(NRL)
# Bradley Terry Implementation with Additional Flexibility
# Rowan Elson-Green - University of Queensland School of Mathematics and Physics
library("BradleyTerry2")
FuncSum1 <- function(f, vector1) {
ans <- 0
for (val in vector1) {
ans = ans + f(val)
}
print(ans)
}
BradTer <- function(dataset) {
# outcome <- arbitrary parameter matrix
# player 1 and 2 corresponding to the winner/loser of outcome columns
wintable <- as.data.frame(table(dataset))
# Converts to table of counts
K <- length(unique(dataset[,1]))
testvec <- rep(1, nrow(dataset))
parvec <- c(1:16)
for (i in 1:K) {
team1 <- levels(wintable[,1])[i]
y <- 0
for (j in 1:K) {
team2 <- levels(wintable[,2])[j]
count <- 0
## algorithm for single comparison
for (winner in wintable[,1]) {
count <- count + 1
x <- count
wij <- 0
if(winner == team1) {
if(wintable[,2][count] == team2) {
nij <- wij + wintable[x,3]
}
y = y + (nij*log(testvec[i]) - nij*log(testvec[i] + testvec[j]))
z <- y
}
parvec[i] <- z
}
}
}
print(parvec)
}
NRL <- read.csv(file = "NRL.csv", row.names = 1)
BradTer(NRL)
# Bradley Terry Implementation with Additional Flexibility
# Rowan Elson-Green - University of Queensland School of Mathematics and Physics
library("BradleyTerry2")
FuncSum1 <- function(f, vector1) {
ans <- 0
for (val in vector1) {
ans = ans + f(val)
}
print(ans)
}
BradTer <- function(dataset) {
# outcome <- arbitrary parameter matrix
# player 1 and 2 corresponding to the winner/loser of outcome columns
wintable <- as.data.frame(table(dataset))
# Converts to table of counts
K <- length(unique(dataset[,1]))
testvec <- rep(1, nrow(dataset))
parvec <- c(1:16)
for (i in 1:K) {
team1 <- levels(wintable[,1])[i]
print(team1)
y <- 0
for (j in 1:K) {
team2 <- levels(wintable[,2])[j]
count <- 0
## algorithm for single comparison
for (winner in wintable[,1]) {
count <- count + 1
x <- count
wij <- 0
if(winner == team1) {
if(wintable[,2][count] == team2) {
nij <- wij + wintable[x,3]
}
y = y + (nij*log(testvec[i]) - nij*log(testvec[i] + testvec[j]))
z <- y
}
parvec[i] <- z
}
}
}
print(parvec)
}
NRL <- read.csv(file = "NRL.csv", row.names = 1)
BradTer(NRL)
# Predictor set from BradleyTerry2
# Allows user to find win probabilities for a contest
library("BradleyTerry2")
BTmpredict <- function(model1, player1, player2) {
# For the test model (NRL 2017 dataset) player names have a .. in front
# e.g for player1 to be Broncos, must be ..BRO
mod <- model1$coefficients
logodds <- c()
players <- (1:length(model1$coefficients))
for (i in players) {
logodds <- c(logodds, mod[i])
}
ans <- logodds[player1]/(logodds[player1]+logodds[player2])
names(ans) = c()
cat(player1, "Has a", ans, "chance of beating", player2)
}
NRL <- read.csv(file = "NRL.csv", row.names=1)
results <- rep(1, nrow(NRL))
NRLModel <- BTm(results, Winner, Loser, data = NRL, refcat="NEW")
summary(NRLModel)
BTmpredict(NRLModel, "..BRO", "..MEL")
# Bradley Terry Implementation with Additional Flexibility
# Rowan Elson-Green - University of Queensland School of Mathematics and Physics
library("BradleyTerry2")
FuncSum1 <- function(f, vector1) {
ans <- 0
for (val in vector1) {
ans = ans + f(val)
}
print(ans)
}
BradTer <- function(dataset) {
# outcome <- arbitrary parameter matrix
# player 1 and 2 corresponding to the winner/loser of outcome columns
wintable <- as.data.frame(table(dataset))
# Converts to table of counts
K <- length(unique(dataset[,1]))
testvec <- rep(1, nrow(dataset))
parvec <- c(1:16)
teamnames <- c()
for (i in 1:K) {
team1 <- levels(wintable[,1])[i]
teamnames <- c(teamnames, team1)
y <- 0
for (j in 1:K) {
team2 <- levels(wintable[,2])[j]
count <- 0
## algorithm for single comparison
for (winner in wintable[,1]) {
count <- count + 1
x <- count
wij <- 0
if(winner == team1) {
if(wintable[,2][count] == team2) {
nij <- wij + wintable[x,3]
}
y = y + (nij*log(testvec[i]) - nij*log(testvec[i] + testvec[j]))
z <- y
}
parvec[i] <- z
}
}
}
names(parvec) <- teamnames
print(parvec)
}
NRL <- read.csv(file = "NRL.csv", row.names = 1)
BradTer(NRL)
# Bradley Terry Implementation with Additional Flexibility
# Rowan Elson-Green - University of Queensland School of Mathematics and Physics
library("BradleyTerry2")
FuncSum1 <- function(f, vector1) {
ans <- 0
for (val in vector1) {
ans = ans + f(val)
}
print(ans)
}
BradTer <- function(dataset) {
# outcome <- arbitrary parameter matrix
# player 1 and 2 corresponding to the winner/loser of outcome columns
wintable <- as.data.frame(table(dataset))
# Converts to table of counts
K <- length(unique(dataset[,1]))
testvec <- array(1, 16)/16
parvec <- c(1:16)
teamnames <- c()
for (i in 1:K) {
team1 <- levels(wintable[,1])[i]
teamnames <- c(teamnames, team1)
y <- 0
for (j in 1:K) {
team2 <- levels(wintable[,2])[j]
count <- 0
## algorithm for single comparison
for (winner in wintable[,1]) {
count <- count + 1
x <- count
wij <- 0
if(winner == team1) {
if(wintable[,2][count] == team2) {
nij <- wij + wintable[x,3]
}
y = y + (nij*log(testvec[i]) - nij*log(testvec[i] + testvec[j]))
z <- y
}
parvec[i] <- z
}
}
}
names(parvec) <- teamnames
print(parvec)
}
NRL <- read.csv(file = "NRL.csv", row.names = 1)
BradTer(NRL)
# Bradley Terry Implementation with Additional Flexibility
# Rowan Elson-Green - University of Queensland School of Mathematics and Physics
library("BradleyTerry2")
FuncSum1 <- function(f, vector1) {
ans <- 0
for (val in vector1) {
ans = ans + f(val)
}
print(ans)
}
BradTer <- function(dataset) {
# outcome <- arbitrary parameter matrix
# player 1 and 2 corresponding to the winner/loser of outcome columns
wintable <- as.data.frame(table(dataset))
# Converts to table of counts
K <- length(unique(dataset[,1]))
testvec <- array(1, 16)/16
print(testvec)
parvec <- c(1:16)
teamnames <- c()
for (i in 1:K) {
team1 <- levels(wintable[,1])[i]
teamnames <- c(teamnames, team1)
y <- 0
for (j in 1:K) {
team2 <- levels(wintable[,2])[j]
count <- 0
## algorithm for single comparison
for (winner in wintable[,1]) {
count <- count + 1
x <- count
wij <- 0
if(winner == team1) {
if(wintable[,2][count] == team2) {
nij <- wij + wintable[x,3]
}
y = y + (nij*log(testvec[i]) - nij*log(testvec[i] + testvec[j]))
z <- y
}
parvec[i] <- z
}
}
}
names(parvec) <- teamnames
print(parvec)
}
NRL <- read.csv(file = "NRL.csv", row.names = 1)
BradTer(NRL)
table(NRL)
as.data.frame(NRL)
as.data.frame(table(NRL))
countsToBinomial(as.data.frame(table(NRL)))
=======
# K is number of elements for comparison (Caron and Doucet)
lambda1 = array(1, K)
# labmda = {lambda_i}_(i=1)^K
teamnames <- unique(data[,1])
wi <- lambda1
names(wi) <- teamnames
for (team in teamnames) {
wins <- which(data[,1]==team)
wij <- data[wins,]
wincount <- data[wins,3]
wi[team] <- sum(wincount)
# wi is total wins by i
}
return(wi)
}
Wij <- function(i, j, data) {
#For a given i and j, generates the number of times i has beaten j, data should be provided as a counts table
iloc <- which(data[,1] == i)
jloc <- which(data[,2] == j)
# Generates vectors defining the locations where i is the winner and j is the loser
ij <- intersect(iloc, jloc)
# Finds the common location between the two location vectors
wij <- data[ij,3]
return(wij)
# Returns the count at the common location
}
Nij <- function(i, j, data) {
# For a given i and j, generates the number of times i has faced j
wij <- Wij(i, j, data)
wji <- Wij(j, i, data)
return(wij + wji)
}
Hun1 <- function(i, j, data, L, k=1) {
nij <- Nij(i, j, data)
li <- L[i]
lj <- L[j]
return(nij/(li^k + lj^k))
}
liIter <- function(i, data, L, k=1) {
wi <- Wi(data)
liVec <- c()
for (j in names(L)) {
if (j != i) {
liVec <- c(liVec, Hun1(i, j, data, L, k))
}
}
liSum <- sum(liVec)
return(wi[i] * liSum^-1)
}
PlanB <- function(data, L, k=1) {
if (k > 2) {
min(L) <- para
print(para)
L <- L*(1/para)
print(L)
}
else {
print(L)
ansL <- L
for (i in names(L)) {
L[i] <- liIter(i, data, ansL, k)
}
PlanB(data, L, k+1)}
}
NRL <- read.csv("NRL.csv", row.names=1)
NRL <- as.data.frame(table(NRL))
#Wij("BRO", "CAN", as.data.frame(table(NRL)))
#Nij("BRO", "CAN", as.data.frame(table(NRL)))
L <- array(1, 16)
names(L) <- unique(NRL[,1])
#liIter("MEL", NRL, L)
PlanB(NRL, L)
# Implementation of Hunter 2004 iterative algorithm to maximize lambda
Wi <- function(data) {
# Create arbitrary intial vector
K <- length(unique(data[,1]))
# K is number of elements for comparison (Caron and Doucet)
lambda1 = array(1, K)
# labmda = {lambda_i}_(i=1)^K
teamnames <- unique(data[,1])
wi <- lambda1
names(wi) <- teamnames
for (team in teamnames) {
wins <- which(data[,1]==team)
wij <- data[wins,]
wincount <- data[wins,3]
wi[team] <- sum(wincount)
# wi is total wins by i
}
return(wi)
}
Wij <- function(i, j, data) {
#For a given i and j, generates the number of times i has beaten j, data should be provided as a counts table
iloc <- which(data[,1] == i)
jloc <- which(data[,2] == j)
# Generates vectors defining the locations where i is the winner and j is the loser
ij <- intersect(iloc, jloc)
# Finds the common location between the two location vectors
wij <- data[ij,3]
return(wij)
# Returns the count at the common location
}
Nij <- function(i, j, data) {
# For a given i and j, generates the number of times i has faced j
wij <- Wij(i, j, data)
wji <- Wij(j, i, data)
return(wij + wji)
}
Hun1 <- function(i, j, data, L, k=1) {
nij <- Nij(i, j, data)
li <- L[i]
lj <- L[j]
return(nij/(li^k + lj^k))
}
liIter <- function(i, data, L, k=1) {
wi <- Wi(data)
liVec <- c()
for (j in names(L)) {
if (j != i) {
liVec <- c(liVec, Hun1(i, j, data, L, k))
}
}
liSum <- sum(liVec)
return(wi[i] * liSum^-1)
}
PlanB <- function(data, L, k=1) {
if (k > 2) {
min(L) <- para
print(para)
L <- L*(1/para)
print(L)
}
else {
ansL <- L
for (i in names(L)) {
L[i] <- liIter(i, data, ansL, k)
}
PlanB(data, L, k+1)}
}
NRL <- read.csv("NRL.csv", row.names=1)
NRL <- as.data.frame(table(NRL))
#Wij("BRO", "CAN", as.data.frame(table(NRL)))
#Nij("BRO", "CAN", as.data.frame(table(NRL)))
L <- array(1, 16)
names(L) <- unique(NRL[,1])
#liIter("MEL", NRL, L)
PlanB(NRL, L)
# Implementation of Hunter 2004 iterative algorithm to maximize lambda
Wi <- function(data) {
# Create arbitrary intial vector
K <- length(unique(data[,1]))
# K is number of elements for comparison (Caron and Doucet)
lambda1 = array(1, K)
# labmda = {lambda_i}_(i=1)^K
teamnames <- unique(data[,1])
wi <- lambda1
names(wi) <- teamnames
for (team in teamnames) {
wins <- which(data[,1]==team)
wij <- data[wins,]
wincount <- data[wins,3]
wi[team] <- sum(wincount)
# wi is total wins by i
}
return(wi)
}
Wij <- function(i, j, data) {
#For a given i and j, generates the number of times i has beaten j, data should be provided as a counts table
iloc <- which(data[,1] == i)
jloc <- which(data[,2] == j)
# Generates vectors defining the locations where i is the winner and j is the loser
ij <- intersect(iloc, jloc)
# Finds the common location between the two location vectors
wij <- data[ij,3]
return(wij)
# Returns the count at the common location
}
Nij <- function(i, j, data) {
# For a given i and j, generates the number of times i has faced j
wij <- Wij(i, j, data)
wji <- Wij(j, i, data)
return(wij + wji)
}
Hun1 <- function(i, j, data, L, k=1) {
nij <- Nij(i, j, data)
li <- L[i]
lj <- L[j]
return(nij/(li^k + lj^k))
}
liIter <- function(i, data, L, k=1) {
wi <- Wi(data)
liVec <- c()
for (j in names(L)) {
if (j != i) {
liVec <- c(liVec, Hun1(i, j, data, L, k))
}
}
liSum <- sum(liVec)
return(wi[i] * liSum^-1)
}
PlanB <- function(data, L, k=1) {
if (k > 2) {
L <- L*(1/min(L))
print(L)
}
else {
ansL <- L
for (i in names(L)) {
L[i] <- liIter(i, data, ansL, k)
}
PlanB(data, L, k+1)}
}
NRL <- read.csv("NRL.csv", row.names=1)
NRL <- as.data.frame(table(NRL))
#Wij("BRO", "CAN", as.data.frame(table(NRL)))
#Nij("BRO", "CAN", as.data.frame(table(NRL)))
L <- array(1, 16)
names(L) <- unique(NRL[,1])
#liIter("MEL", NRL, L)
PlanB(NRL, L)
# Implementation of Hunter 2004 iterative algorithm to maximize lambda
Wi <- function(data) {
# Create arbitrary intial vector
K <- length(unique(data[,1]))
# K is number of elements for comparison (Caron and Doucet)
lambda1 = array(1, K)
# labmda = {lambda_i}_(i=1)^K
teamnames <- unique(data[,1])
wi <- lambda1
names(wi) <- teamnames
for (team in teamnames) {
wins <- which(data[,1]==team)
wij <- data[wins,]
wincount <- data[wins,3]
wi[team] <- sum(wincount)
# wi is total wins by i
}
return(wi)
}
Wij <- function(i, j, data) {
#For a given i and j, generates the number of times i has beaten j, data should be provided as a counts table
iloc <- which(data[,1] == i)
jloc <- which(data[,2] == j)
# Generates vectors defining the locations where i is the winner and j is the loser
ij <- intersect(iloc, jloc)
# Finds the common location between the two location vectors
wij <- data[ij,3]
return(wij)
# Returns the count at the common location
}
Nij <- function(i, j, data) {
# For a given i and j, generates the number of times i has faced j
wij <- Wij(i, j, data)
wji <- Wij(j, i, data)
return(wij + wji)
}
Hun1 <- function(i, j, data, L, k=1) {
nij <- Nij(i, j, data)
li <- L[i]
lj <- L[j]
return(nij/(li^k + lj^k))
}
liIter <- function(i, data, L, k=1) {
wi <- Wi(data)
liVec <- c()
for (j in names(L)) {
if (j != i) {
liVec <- c(liVec, Hun1(i, j, data, L, k))
}
}
liSum <- sum(liVec)
return(wi[i] * liSum^-1)
}
PlanB <- function(data, L, k=1) {
if (k > 10) {
L <- L*(1/min(L))
print(L)
}
else {
ansL <- L
for (i in names(L)) {
L[i] <- liIter(i, data, ansL, k)
}
PlanB(data, L, k+1)}
}
NRL <- read.csv("NRL.csv", row.names=1)
NRL <- as.data.frame(table(NRL))
#Wij("BRO", "CAN", as.data.frame(table(NRL)))
#Nij("BRO", "CAN", as.data.frame(table(NRL)))
L <- array(1, 16)
names(L) <- unique(NRL[,1])
#liIter("MEL", NRL, L)
PlanB(NRL, L)
# Implementation of Hunter 2004 iterative algorithm to maximize lambda
Wi <- function(data) {
# Create arbitrary intial vector
K <- length(unique(data[,1]))
# K is number of elements for comparison (Caron and Doucet)
lambda1 = array(1, K)
# labmda = {lambda_i}_(i=1)^K
teamnames <- unique(data[,1])
wi <- lambda1
names(wi) <- teamnames
for (team in teamnames) {
wins <- which(data[,1]==team)
wij <- data[wins,]
wincount <- data[wins,3]
wi[team] <- sum(wincount)
# wi is total wins by i
}
return(wi)
}
Wij <- function(i, j, data) {
#For a given i and j, generates the number of times i has beaten j, data should be provided as a counts table
iloc <- which(data[,1] == i)
jloc <- which(data[,2] == j)
# Generates vectors defining the locations where i is the winner and j is the loser
ij <- intersect(iloc, jloc)
# Finds the common location between the two location vectors
wij <- data[ij,3]
return(wij)
# Returns the count at the common location
}
Nij <- function(i, j, data) {
# For a given i and j, generates the number of times i has faced j
wij <- Wij(i, j, data)
wji <- Wij(j, i, data)
return(wij + wji)
}
Hun1 <- function(i, j, data, L, k=1) {
nij <- Nij(i, j, data)
li <- L[i]
lj <- L[j]
return(nij/(li^k + lj^k))
}
liIter <- function(i, data, L, k=1) {
wi <- Wi(data)
liVec <- c()
for (j in names(L)) {
if (j != i) {
liVec <- c(liVec, Hun1(i, j, data, L, k))
}
}
liSum <- sum(liVec)
return(wi[i] * liSum^-1)
}
PlanB <- function(data, L, k=1) {
if (k > 5) {
L <- L*(1/min(L))
print(L)
}
else {
ansL <- L
for (i in names(L)) {
L[i] <- liIter(i, data, ansL, k)
}
PlanB(data, L, k+1)}
}
NRL <- read.csv("NRL.csv", row.names=1)
NRL <- as.data.frame(table(NRL))
#Wij("BRO", "CAN", as.data.frame(table(NRL)))
#Nij("BRO", "CAN", as.data.frame(table(NRL)))
L <- array(1, 16)
names(L) <- unique(NRL[,1])
#liIter("MEL", NRL, L)
PlanB(NRL, L)
# Implementation of Hunter 2004 iterative algorithm to maximize lambda
Wi <- function(data) {
# Create arbitrary intial vector
K <- length(unique(data[,1]))
# K is number of elements for comparison (Caron and Doucet)
lambda1 = array(1, K)
# labmda = {lambda_i}_(i=1)^K
teamnames <- unique(data[,1])
wi <- lambda1
names(wi) <- teamnames
for (team in teamnames) {
wins <- which(data[,1]==team)
wij <- data[wins,]
wincount <- data[wins,3]
wi[team] <- sum(wincount)
# wi is total wins by i
}
return(wi)
}
Wij <- function(i, j, data) {
#For a given i and j, generates the number of times i has beaten j, data should be provided as a counts table
iloc <- which(data[,1] == i)
jloc <- which(data[,2] == j)
# Generates vectors defining the locations where i is the winner and j is the loser
ij <- intersect(iloc, jloc)
# Finds the common location between the two location vectors
wij <- data[ij,3]
return(wij)
# Returns the count at the common location
}
Nij <- function(i, j, data) {
# For a given i and j, generates the number of times i has faced j
wij <- Wij(i, j, data)
wji <- Wij(j, i, data)
return(wij + wji)
}
Hun1 <- function(i, j, data, L, k=1) {
nij <- Nij(i, j, data)
li <- L[i]
lj <- L[j]
return(nij/(li^k + lj^k))
}
liIter <- function(i, data, L, k=1) {
wi <- Wi(data)
liVec <- c()
for (j in names(L)) {
if (j != i) {
liVec <- c(liVec, Hun1(i, j, data, L, k))
}
}
liSum <- sum(liVec)
return(wi[i] * liSum^-1)
}
PlanB <- function(data, L, k=1) {
if (k > 3) {
L <- L*(1/min(L))
print(L)
}
else {
ansL <- L
for (i in names(L)) {
L[i] <- liIter(i, data, ansL, k)
}
PlanB(data, L, k+1)}
}
NRL <- read.csv("NRL.csv", row.names=1)
NRL <- as.data.frame(table(NRL))
#Wij("BRO", "CAN", as.data.frame(table(NRL)))
#Nij("BRO", "CAN", as.data.frame(table(NRL)))
L <- array(1, 16)
names(L) <- unique(NRL[,1])
#liIter("MEL", NRL, L)
PlanB(NRL, L)
# Implementation of Hunter 2004 iterative algorithm to maximize lambda
Wi <- function(data) {
# Create arbitrary intial vector
K <- length(unique(data[,1]))
# K is number of elements for comparison (Caron and Doucet)
lambda1 = array(1, K)
# labmda = {lambda_i}_(i=1)^K
teamnames <- unique(data[,1])
wi <- lambda1
names(wi) <- teamnames
for (team in teamnames) {
wins <- which(data[,1]==team)
wij <- data[wins,]
wincount <- data[wins,3]
wi[team] <- sum(wincount)
# wi is total wins by i
}
return(wi)
}
Wij <- function(i, j, data) {
#For a given i and j, generates the number of times i has beaten j, data should be provided as a counts table
iloc <- which(data[,1] == i)
jloc <- which(data[,2] == j)
# Generates vectors defining the locations where i is the winner and j is the loser
ij <- intersect(iloc, jloc)
# Finds the common location between the two location vectors
wij <- data[ij,3]
return(wij)
# Returns the count at the common location
}
Nij <- function(i, j, data) {
# For a given i and j, generates the number of times i has faced j
wij <- Wij(i, j, data)
wji <- Wij(j, i, data)
return(wij + wji)
}
Hun1 <- function(i, j, data, L, k=1) {
nij <- Nij(i, j, data)
li <- L[i]
lj <- L[j]
return(nij/(li^k + lj^k))
}
liIter <- function(i, data, L, k=1) {
wi <- Wi(data)
liVec <- c()
for (j in names(L)) {
if (j != i) {
liVec <- c(liVec, Hun1(i, j, data, L, k))
}
}
liSum <- sum(liVec)
return(wi[i] * liSum^-1)
}
PlanB <- function(data, L, k=1) {
if (k > 2) {
L <- L*(1/min(L))
print(L)
}
else {
ansL <- L
for (i in names(L)) {
L[i] <- liIter(i, data, ansL, k)
}
PlanB(data, L, k+1)}
}
NRL <- read.csv("NRL.csv", row.names=1)
NRL <- as.data.frame(table(NRL))
#Wij("BRO", "CAN", as.data.frame(table(NRL)))
#Nij("BRO", "CAN", as.data.frame(table(NRL)))
L <- array(1, 16)
names(L) <- unique(NRL[,1])
#liIter("MEL", NRL, L)
PlanB(NRL, L)
>>>>>>> 084956c24b1c69f082f63661c606ccc4a48084d2
